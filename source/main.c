#include <tonc.h>

// This file is autogenerated from the file in the graphics folder
//#include "as1.h"
//#include "as2.h"
//#include "ship.h"
#include "spritemap.h"
#include "bg.h"

// 32 objects with affine transformation
OBJ_ATTR obj_buffer[128];
OBJ_AFFINE *obj_aff_buffer = (OBJ_AFFINE*)obj_buffer;

enum {
  SCENE_START = -1,
  SCENE_MENU = 0,
  SCENE_GAME = 1,
} scene = SCENE_MENU, old_scene = SCENE_START;

struct GAME_STATE {
  int as_count;
} game_state = {
  .as_count = 0,
};

u32 timer_last = 0;
u32 timer = 1;
#define TIMER(c) ((timer & (c)) != 0 && ((timer_last & (c)) == 0))

#define SPRITE_SIZE 16

#define SCREEN_WIDTH 240
#define SCREEN_HEIGHT 160

#define PLAYER_ROT_SCALE 400 // higher means faster rotation
#define PLAYER_MOVE_SCALE 0.008 // higher means faster movement
#define PLAYER_MAX_ACC 0.1 // higher means faster movement

#define ACCELERATION_SCALE 100 // higher means slower deceleration

#define ASTEROID_MOVE_SCALE 10000

#define SHOT_RELOAD_TIME 50


#define TILE_POS(x, y) ((x) + ((y) * 16))


#define TILE_PLAYER TILE_POS(0, 0)
#define TILE_PLAYER_MOVE_END TILE_POS(3, 0)

#define TILE_AS1    TILE_POS(0, 1)
#define TILE_AS2    TILE_POS(1, 1)
#define TILE_AS3    TILE_POS(2, 1)
#define TILE_AS4    TILE_POS(3, 1)
#define TILE_AS5    TILE_POS(4, 1)
#define TILE_AS6    TILE_POS(5, 1)
#define TILE_AS7    TILE_POS(6, 1)
#define TILE_AS8    TILE_POS(7, 1)

#define TILE_AS_DESTROY TILE_POS(0, 2)
#define TILE_AS_DESTROY_END TILE_POS(2, 2)
#define AS_DESTROY_ANIM_COUNT 3

#define TILE_SHOT TILE_POS(0, 3)

#define TILE_PLAYER_DESTROY TILE_POS(0, 4)
#define TILE_PLAYER_DESTROY_END TILE_POS(5, 4)

#define TILE_CURSOR TILE_POS(0, 5)
#define TILE_CURSOR_END TILE_POS(1, 5)

#define OBJ_PLAYER 0
#define OBJ_AS1    1
#define OBJ_AS2    2
#define OBJ_AS3    3
#define OBJ_AS4    4
#define OBJ_AS5    5
#define OBJ_AS6    6
#define OBJ_AS7    7
#define OBJ_AS8    8

#define SPRITE_OFFSET ((SPRITE_SIZE / 2) + SPRITE_SIZE)

struct VEC {
  FIXED x;
  FIXED y;
};

struct OBJ {
  struct VEC pos;
  struct VEC vel;
  struct VEC acc;
  FIXED drag;
  int size; // i.e. radius

  int rot;

  OBJ_ATTR *attr;
  OBJ_AFFINE *aff;
  OBJ_AFFINE aff_base;
  int tile;
} objs[] = {
  { .attr=&obj_buffer[0], .aff=(OBJ_AFFINE*)&obj_buffer[0 * 4], .tile=TILE_PLAYER, .size=10 },
  { .attr=&obj_buffer[1], .aff=(OBJ_AFFINE*)&obj_buffer[1 * 4], .tile=TILE_SHOT, .size=10 },
  { .attr=&obj_buffer[2], .aff=(OBJ_AFFINE*)&obj_buffer[2 * 4], .tile=TILE_CURSOR, .size=0 },
  { .attr=&obj_buffer[3], .aff=(OBJ_AFFINE*)&obj_buffer[3 * 4], .tile=TILE_AS1, .size=3 },
  { .attr=&obj_buffer[4], .aff=(OBJ_AFFINE*)&obj_buffer[4 * 4], .tile=TILE_AS2, .size=3 },
  { .attr=&obj_buffer[5], .aff=(OBJ_AFFINE*)&obj_buffer[5 * 4], .tile=TILE_AS3, .size=3 },
  { .attr=&obj_buffer[6], .aff=(OBJ_AFFINE*)&obj_buffer[6 * 4], .tile=TILE_AS4, .size=3 },
  { .attr=&obj_buffer[7], .aff=(OBJ_AFFINE*)&obj_buffer[7 * 4], .tile=TILE_AS5, .size=3 },
  { .attr=&obj_buffer[8], .aff=(OBJ_AFFINE*)&obj_buffer[8 * 4], .tile=TILE_AS6, .size=3 },
  { .attr=&obj_buffer[9], .aff=(OBJ_AFFINE*)&obj_buffer[9 * 4], .tile=TILE_AS7, .size=3 },
  { .attr=&obj_buffer[10], .aff=(OBJ_AFFINE*)&obj_buffer[10 * 4], .tile=TILE_AS8, .size=3 }
};

#define OBJ_COUNT (sizeof(objs) / sizeof(objs[0]))

struct PLAYER {
  struct OBJ* obj;
  int is_destroyed;
} player = {
  .obj=&objs[0],
  .is_destroyed = 0
};

struct SHOT {
  struct OBJ *obj;
  int is_active;
  int is_hot;
  int time;
} shot = {
  .obj = &objs[1],
  .is_active = 0,
  .is_hot = 0,
  .time = 0
};

struct ASTEROID {
  struct OBJ* obj;
  int destroyed_time;
  int rot_vel;
  int tile;
} asteroids[] = {
  { .obj=&objs[3], .destroyed_time=1, .tile=TILE_AS1 },
  { .obj=&objs[4], .destroyed_time=1, .tile=TILE_AS2 },
  { .obj=&objs[5], .destroyed_time=1, .tile=TILE_AS3 },
  { .obj=&objs[6], .destroyed_time=1, .tile=TILE_AS4 },
  { .obj=&objs[7], .destroyed_time=1, .tile=TILE_AS5 },
  { .obj=&objs[8], .destroyed_time=1, .tile=TILE_AS6 },
  { .obj=&objs[9], .destroyed_time=1, .tile=TILE_AS7 },
  { .obj=&objs[10], .destroyed_time=1, .tile=TILE_AS8 }
};

struct CURSOR {
  struct OBJ *obj;
} cursor = {
  .obj = &objs[2]
};

#define ASTEROID_COUNT (sizeof(asteroids) / sizeof(asteroids[0]))

void v_add(struct VEC* v, FIXED x, FIXED y)
{
  v->x = fxadd(v->x, x);
  v->y = fxadd(v->y, y);
}

void v_mul(struct VEC* v, FIXED a)
{
  v->x = fxmul(v->x, a);
  v->y = fxmul(v->y, a);
}

FIXED v_size_s(struct VEC* v)
{
  return fxadd(fxmul(v->x, v->x), fxmul(v->y, v->y));
}

int v_size_lt(struct VEC* v, FIXED a)
{
  return v_size_s(v) < a * a;
}

void obj_disable(struct OBJ *obj)
{
  obj->attr->attr0 = ATTR0_SQUARE | ATTR0_8BPP | ATTR0_HIDE;
}

void obj_enable(struct OBJ *obj)
{
  obj->attr->attr0 = ATTR0_SQUARE | ATTR0_8BPP | ATTR0_AFF_DBL;
}

void objs_disable()
{
  for (int i = 0; i < OBJ_COUNT; i++) {
    obj_disable(&objs[i]);
  }
}

void obj_init(struct OBJ* obj, int index)
{
  obj_set_attr(
    obj->attr,
    ATTR0_SQUARE | ATTR0_8BPP | ATTR0_HIDE, // leave out ATTR0_AFF_DBL initially
    ATTR1_SIZE_16 | ATTR1_AFF_ID(index),
    ATTR2_PALBANK(0) | ATTR2_ID(obj->tile * 4)
  );
  obj_set_pos(obj->attr, 0, 0);
  obj_aff_identity(obj->aff);
  obj_aff_identity(&obj->aff_base);

  obj->pos.x = 0;
  obj->pos.y = 0;
  obj->vel.x = 0;
  obj->vel.y = 0;
  obj->acc.x = 0;
  obj->acc.y = 0;
  obj->drag = int2fx(1);
}

void obj_tile_update(struct OBJ *obj)
{
  obj->attr->attr2 = ATTR2_PALBANK(0) | ATTR2_ID(obj->tile * 4);
}

void obj_rot_update(struct OBJ* obj)
{
  obj_aff_rotate(&obj->aff_base, obj->rot);
  obj_aff_copy(obj->aff, &obj->aff_base, 1);
  obj_aff_postmul(obj->aff, &obj->aff_base);
}

void obj_pos_wrap(struct OBJ* obj)
{
  // Due to AFF_DBL, we need to check for double the sprites size
#define SCREEN_LEFT_OUT (-(SPRITE_SIZE + (SPRITE_SIZE / 2)))
#define SCREEN_RIGHT_OUT (SCREEN_WIDTH - (SPRITE_SIZE / 2))
#define SCREEN_TOP_OUT (-(SPRITE_SIZE + (SPRITE_SIZE / 2)))
#define SCREEN_BOTTOM_OUT (SCREEN_HEIGHT - (SPRITE_SIZE / 2))

  int discrete_x = fx2int(obj->pos.x);
  int discrete_y = fx2int(obj->pos.y);

  if (discrete_x < SCREEN_LEFT_OUT) obj->pos.x = int2fx(SCREEN_RIGHT_OUT);
  else if (discrete_x > SCREEN_RIGHT_OUT) obj->pos.x = int2fx(SCREEN_LEFT_OUT);

  if (discrete_y < SCREEN_TOP_OUT) obj->pos.y = int2fx(SCREEN_BOTTOM_OUT);
  else if (discrete_y > SCREEN_BOTTOM_OUT) obj->pos.y = int2fx(SCREEN_TOP_OUT);
}

int obj_check_coll(struct OBJ *a, struct OBJ *b)
{
  int dx = fx2int(a->pos.x - b->pos.x);
  int dy = fx2int(a->pos.y - b->pos.y);
  int dc = a->size + b->size;

  return (dx * dx + dy * dy <= dc * dc);
}

void obj_pos_update(struct OBJ* obj, int wrap)
{
  // update vel
  v_add(&obj->vel, obj->acc.x, obj->acc.y);

  // apply drag
  obj->vel.x = fxmul(obj->vel.x, obj->drag);
  obj->vel.y = fxmul(obj->vel.y, obj->drag);

  // update pos
  v_add(&obj->pos, obj->vel.x, obj->vel.y);

  if (wrap) {
    obj_pos_wrap(obj);
  }

  obj_set_pos(obj->attr, fx2int(obj->pos.x), fx2int(obj->pos.y));
}

void init_sprites(void)
{
  memcpy32(&tile_mem[4][0], spritemapTiles, spritemapTilesLen / 4);
  memcpy32(pal_obj_mem, spritemapPal, spritemapPalLen / 4);

  // iterate over objects
  for (int i = 0; i < OBJ_COUNT; i++) {
    obj_init(&objs[i], i);
  }
}

void init_bg(void)
{
  memcpy32(&tile_mem[1][0], bgTiles, bgTilesLen / 4);
  memcpy32(pal_bg_mem, bgPal, bgPalLen / 4);
  REG_BG0CNT = BG_CBB(1) | BG_SBB(16) | BG_8BPP | BG_REG_32x32;
  for (int i = 0; i < 32 * 32; i++) {
    se_mem[16][i] = qran_range(0, 64);
  }
}

void init_text(void)
{
  //tte_init_chr4c_b4_default(0, BG_CBB(0) | BG_SBB(28));
  //tte_init_con();
  //tte_set_margins(8, 128, 232, 160);
}

void init(void)
{
  irq_init(NULL);
  irq_enable(II_VBLANK);

  REG_DISPCNT = DCNT_MODE0 | DCNT_BG0 | DCNT_BG1 | DCNT_OBJ | DCNT_OBJ_2D;
  oam_init(obj_buffer, 128);

  init_sprites();
  init_bg();
  init_text(); // init text last so that it writes its colors into the palette last
}

void scroll_bg(void)
{
  static int x;
  static int y;
  x += TIMER(32) * 1;
  y += TIMER(32) * 1;
  REG_BG0HOFS = x;
  REG_BG0VOFS = y;
}

void menu_update(void)
{
  scroll_bg();
  cursor.obj->tile ^= TIMER(8);
  obj_tile_update(cursor.obj);

  if (key_was_up(KEY_A) && key_is_down(KEY_A)) {
    scene = SCENE_GAME;
  }

  obj_copy(obj_mem, obj_buffer, OBJ_COUNT);
}

void menu_init(void)
{
  //tte_erase_rect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
  objs_disable();

  obj_enable(cursor.obj);
  cursor.obj->pos.x = int2fx(SCREEN_WIDTH / 2 - 60);
  cursor.obj->pos.y = int2fx(51);
  obj_pos_update(cursor.obj, 0);

  //tte_set_pos(75, 30);
  //tte_write("< ASTEROIDS >");

  //tte_set_pos(95, 60);
  //tte_write("start");

}

void player_update()
{
  if (player.is_destroyed) {
    if (player.obj->tile >= TILE_PLAYER_DESTROY_END) {
      scene = SCENE_MENU;
      return;
    }

    player.obj->tile |= TILE_PLAYER_DESTROY;
    player.obj->tile += TIMER(2) * 1;
    obj_tile_update(player.obj);
    return;
  }

  // rotate
  player.obj->rot += PLAYER_ROT_SCALE * !!key_is_down(KEY_LEFT) - PLAYER_ROT_SCALE * !!key_is_down(KEY_RIGHT);

  int sin = -fxdiv(int2fx(lu_sin(player.obj->rot * 2)), 4096);
  int cos = -fxdiv(int2fx(lu_cos(player.obj->rot * 2)), 4096);
  sin = fxmul(sin, float2fx(PLAYER_MOVE_SCALE));
  cos = fxmul(cos, float2fx(PLAYER_MOVE_SCALE));

  if (key_is_down(KEY_UP)) {
    player.obj->acc.x = fxdiv(sin, int2fx(10));
    player.obj->acc.y = fxdiv(cos, int2fx(10));

    player.obj->tile = player.obj->tile * (player.obj->tile < TILE_PLAYER_MOVE_END);
    player.obj->tile += 1;
  } else {
    player.obj->acc.x = 0;
    player.obj->acc.y = 0;

    player.obj->tile = TILE_PLAYER;
  }

  obj_tile_update(player.obj);

  obj_pos_update(player.obj, 1);
  obj_rot_update(player.obj);
}

void shot_update()
{
  if (!shot.is_active) {
    if (!key_is_down(KEY_A)) {
        return;
    }
    shot.is_active = 1;
    shot.is_hot = 1;
    obj_enable(shot.obj);
    shot.time = SHOT_RELOAD_TIME;
    shot.obj->pos.x = player.obj->pos.x;
    shot.obj->pos.y = player.obj->pos.y;

    int sin = fxdiv(int2fx(lu_sin(player.obj->rot * 2)), 4096);
    int cos = fxdiv(int2fx(lu_cos(player.obj->rot * 2)), 4096);
    sin = fxmul(sin, float2fx(PLAYER_MOVE_SCALE * 2));
    cos = fxmul(cos, float2fx(PLAYER_MOVE_SCALE * 2));

    shot.obj->vel.x = -sin;
    shot.obj->vel.y = -cos;
  }
  if (shot.time <= 0 && shot.is_hot == 0) {
    shot.is_active = 0;
    return;
  }
  shot.time--;

  int d_x = fx2int(shot.obj->pos.x);
  int d_y = fx2int(shot.obj->pos.y);

  // why don't we need SPRITE_OFFSET here?
  if (d_x >= SCREEN_WIDTH - SPRITE_SIZE ||
      d_x <= -SPRITE_SIZE ||
      d_y >= SCREEN_HEIGHT - SPRITE_SIZE ||
      d_y <= -SPRITE_SIZE) {
    shot.is_hot = 0;
    obj_disable(shot.obj);
    return;
  }

  obj_pos_update(shot.obj, 0);
}

void asteroid_update(struct ASTEROID* as)
{
  // negative: asteroid is destroyed
  if (as->destroyed_time < 0) {
    // reset asteroid
    if (as->destroyed_time < -AS_DESTROY_ANIM_COUNT * 10) {
      as->destroyed_time = qran_range(20, 200);
      obj_disable(as->obj);
      return;
    }
    as->obj->tile = TILE_POS(-as->destroyed_time / 10, 2);
    obj_tile_update(as->obj);
    as->destroyed_time--;
    return;
  }

  // positive: wait for asteroid to respawn
  if (as->destroyed_time > 1) {
    as->destroyed_time--;
    return;
  }

  // == 1: asteroid just respawned
  if (as->destroyed_time == 1) {
    as->destroyed_time = 0;
    obj_enable(as->obj);
    as->obj->tile = as->tile;
    obj_tile_update(as->obj);

    int px = fx2int(player.obj->pos.x) + SPRITE_OFFSET;

    if (px > SCREEN_WIDTH / 2) {
      as->obj->pos.x = int2fx(px - SCREEN_WIDTH / 2);
    } else {
      as->obj->pos.x = int2fx(px + SCREEN_WIDTH / 2);
    }
    as->obj->pos.y = 0 - int2fx(SPRITE_OFFSET);

    as->obj->vel.x = fxdiv(int2fx(qran_range(-100, 100)), ASTEROID_MOVE_SCALE);
    as->obj->vel.y = fxdiv(int2fx(qran_range(-100, 100)), ASTEROID_MOVE_SCALE);

    as->rot_vel = qran_range(-100, 100);
  }

  if (shot.is_hot && obj_check_coll(as->obj, shot.obj)) {
    as->destroyed_time = -1;
  }

  if (obj_check_coll(as->obj, player.obj)) {
    player.is_destroyed = 1;
  }

  as->obj->rot += as->rot_vel;

  obj_rot_update(as->obj);
  obj_pos_update(as->obj, 1);
}

void game_update(void)
{
  scroll_bg();
  player_update();
  shot_update();

  for (int i = 0; i < game_state.as_count; i++) {
    asteroid_update(&asteroids[i]);
  }

  obj_copy(obj_mem, obj_buffer, OBJ_COUNT);
  obj_aff_copy(obj_aff_mem, obj_aff_buffer, OBJ_COUNT);

  // TODO: fix size
  //tte_erase_rect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
  //tte_printf("#{es;P:0,0}FPS: %d:%d", fx2int(player.obj->acc.x), fx2int(player.obj->acc.y));
}

void game_init(void)
{
  //tte_erase_rect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
  objs_disable();
  sqran(timer);

  // init game state
  game_state.as_count = 2;

  // init player
  player.obj->pos.x = int2fx((SCREEN_WIDTH / 2) - SPRITE_OFFSET);
  player.obj->pos.y = int2fx((SCREEN_HEIGHT / 2) - SPRITE_OFFSET);
  player.is_destroyed = 0;
  player.obj->vel.x = 0;
  player.obj->vel.y = 0;
  player.obj->acc.x = 0;
  player.obj->acc.y = 0;
  player.obj->drag = float2fx(0.98);
  player.obj->tile = TILE_PLAYER;
  player.obj->rot = 0;
  obj_tile_update(player.obj);
  obj_enable(player.obj);

  // init asteroids
  for (int i = 0; i < ASTEROID_COUNT; i++) {
    struct ASTEROID *as = &asteroids[i];
    as->destroyed_time = 1;
  }
}

struct {
  void (*init)(void);
  void (*update)(void);
} SCENES[2] = {
  {menu_init, menu_update},
  {game_init, game_update},
};

int main(void)
{
  init();

  while (1) {
    VBlankIntrWait();
    timer_last = timer;
    timer++;

    key_poll();

    if (old_scene != scene) {
      SCENES[scene].init();
      old_scene = scene;
    }

    SCENES[scene].update();
  }
}
